% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group_every.R
\name{group_every}
\alias{group_every}
\title{Group every N observations together}
\usage{
group_every(data, seconds = NULL, n = NULL)
}
\arguments{
\item{data}{Input data frame}

\item{seconds}{Number of seconds to bin together}

\item{n}{Number of observations to include in each bin/group}
}
\value{
Grouped data frame, with new "bin" variable.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

Sometimes your sampling rate is too high; group_every allows you to
down-sample by creating "bins" which can subsequently be summarised on. When using \code{n}, data
needs to be regularly sampled; if there are gaps in time, the bin duration will differ.
Works well with \code{calculate_summary()} for movement data.
}
\examples{
## Group by every 5 seconds
df_time <- data.frame(
  time = seq(from = 0.02, to = 100, by = 1/30), # time at 30Hz, slightly offset
  y = rnorm(3000)) # random numbers

df_time |>
  group_every(seconds = 5) |> # group for every 5 seconds
  dplyr::summarise(time = min(time), # summarise for time and y
                   mean_y = mean(y)) |>
  dplyr::mutate(time = floor(time)) # floor to get the round second number

# Group every n observations
df <- data.frame(
  x = seq(1:1000),
  y = rnorm(1000))

df |>
  group_every(n = 30) |> # group every 30 observations together
  dplyr::summarise(mean_x = mean(x),
                   mean_y = mean(y))
}
