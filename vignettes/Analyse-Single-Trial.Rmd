---
title: "Analyse single trial"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Analyse-single-trial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Workflow {#workflow}

Working with trackball data is simple, and generally follows the same principles as other movement data sets (e.g. pose estimation, centroid tracking):

- [Read data](#read-data)
- [Clean data](#data-cleaning)
- [Compute kinematics](#compute-kinematics)
- [Visualise kinematics](#visualise)
- [Compute movement statistics](#movement-stats)

## Read data {#read-data}

The primary functionality of the {trackballr} package is to read trackball data. The `read_trackball_data` function requires two file paths one for each sensor. You can find pairs with variations of `list.files()` and for loops. We've included two files as example data in the package from an experiment that used the free configuration:

```{r }
library(trackballr)
system.file("extdata", package = "trackballr") |> list.files()
filepaths <- system.file("extdata", package = "trackballr") |> list.files(full.names = TRUE)
```

Once we have two paths, we can read the data.

```{r}
data <- read_trackball_data(filepaths, configuration = "free")
```

Let's have a look at the data. We see that there is an `x` and `y` column, one reading per sensor. Since the sensors do not capture data at the exact same moments, *trackballr* finds the best alignment of the observations and retains time stamps for both sensors in two formats (we would recommend just using one of the time stamps for further analysis, but it's a good idea to check how closely the frames align).

```{r}
library(dplyr, warn.conflicts = FALSE)
glimpse(data)
```

## Data cleaning {#data-cleaning}

In the current implementation, we assume that the sensors are reliable (no missing observations), so there is no need to impute missing values. Normally, we would also smooth the data in this step, but in the current implementation that happens in [the next step](#compute-kinematics) once we have computed the position in 2D space.

## Compute kinematics {#compute-kinematics}
When we work with movement data, we are often interested in more than just where an animal *is*; we're interested in how fast it moves, where it is heading etc. 
`augment_trackball` computes a range of kinematic variables:

- `cum_x`/`cum_y`: Cumulative position in a 2D space (where they "are" on a map)
- `distance`: The distance the animal moved since the last observation (simply calculated using Pythagoras' theorem)
- `v_translation`: The translational velocity, like what you see on a speedometer in a car.
- `direction`: The direction (in radians) the animal is heading - where the arrow on the compas is heading.
- `rotation`: The amount (in radians) the animal has rotated since the last observation.
- `v_rotation`: The rotational velocity (in rad/s).

```{r}
# Augment all data in list
data_augmented <- augment_trackball(
    data, 
    x, 
    y, 
    sampling_rate = 60,
    rollmean_k = 30,
    mouse_dpcm = 394
    )
glimpse(data_augmented)
```

## Visualise kinematics {#visualise}

We can now visualise the movements and kinematics. 
Let's first have a look at the path.

```{r}
library(tinyplot)
tinyplot(cum_x ~ cum_y, 
         type = "l",
         data = data_augmented,
         xlab = "x",
         ylab = "y"
         )
```

Or the translational velocity:

```{r}
tinyplot(v_translation ~ time, 
         type = "l",
         data = data_augmented,
         xlab = "Time (s)",
         ylab = "V_translation"
         )
```

## Compute movement statistics {#movement-stats}

Finally, we can compute some summary statistics for this trial. There are many possible measures that could be of interest, and we plan to provide a package for these at a later point. For now, here are some examples.

### Translational movement

```{r}
library(tinytable)
data_augmented |> 
  filter(abs(x) > 0 | abs(y) > 0) |> # Only keep rows containing movement
  summarise(total_translation = sum(distance),
            v_translation_mean = mean(v_translation),
            v_translation_sd = sd(v_translation),
            sinuosity = sum(distance)/sqrt(last(cum_x)^2 + last(cum_y)^2)
            ) |> 
  tinytable::tt()
```

### Rotational movement

```{r}
data_augmented |> 
  na.omit() |>
  filter(v_rotation > 0) |>
  summarise(total_rotation = sum(rotation, na.rm = TRUE),
            v_rotation_mean = mean(v_rotation, na.rm = TRUE)) |> 
  tinytable::tt()
```

